# Jetstack Secure demos

Introduction
============

Jetstack Secure provides both operations and security teams with a stand-out solution that best meets their respective needs for a high-level of platform automation, coupled with best practice security. With cert-manager (created and maintained primarily by Jetstack, a Venafi company)â€¯ at its core, Jetstack Secure delivers comprehensive and highly-automated protection of machine identities, including public trusted certificates for ingress TLS, as well as private certificates for internal workloads using mTLS, including service mesh. It gives platform Leads the confidence to scale-up infrastructure, with full automation that adheres to enterprise security standards and gives both platform and security teams complete visibility, across multiple clusters and cloud providers. 

This guide will go through different usecases and the usage of cert-manager and jetstack secure.

Issuers
============================
Issuers, and ClusterIssuers, are Kubernetes resources that represent certificate authorities (CAs) that are able to generate signed certificates by honoring certificate signing requests. All cert-manager certificates require a referenced issuer that is in a ready condition to attempt to honor the request.

### Venafi Issuer

The Venafi Issuer types allows you to obtain certificates from Venafi as a Service (VaaS) and Venafi Trust Protection Platform (TPP) instances.
You can have multiple different Venafi Issuer types installed within the same cluster, including mixtures of Venafi as a Service and TPP issuer types. 

Automated certificate renewal and management are provided for Certificates using the Venafi Issuer.

## Self Signed Issuer
The SelfSigned issuer doesn't represent a certificate authority as such, but instead denotes that certificates will "sign themselves" using a given private key. In other words, the private key of the certificate will be used to sign the certificate itself.

This Issuer type is useful for bootstrapping a root certificate for a custom PKI (Public Key Infrastructure), or for otherwise creating simple ad-hoc certificates.

## Certificate Resource

In cert-manager, the Certificate resource represents a human readable definition of a certificate request that is to be honored by an issuer which is to be kept up-to-date. This is the usual way that you will interact with cert-manager to request signed certificates.

A Certificate resource specifies fields that are used to generate certificate signing requests which are then fulfilled by the issuer type you have referenced.


## Deploy Certmanager to the target cluster

```bash
helm repo add jetstack https://charts.jetstack.io
helm repo update
helm upgrade -i \
  cert-manager jetstack/cert-manager \
  --namespace cert-manager \
  --create-namespace \
  --version v1.8.2 \
  --set installCRDs=true
```

Usecase 1: Generating Java Keystore and Securing a Java Application Using Cert-Manager
=======================================================================================
### Issuer and Certs

Create a namespace for tenancy

```bash
kubectl create ns truststores

```

Create a self signed issuer, create ca cert from the issuer and create a issuer from the CA cert 

```bash
kubectl apply -f cert-manager/issuer.yaml 
```
Create a password for the jks keystore

```bash
kubectl create secret generic jks-password-secret --from-literal=password-key=changeit -n truststores
```

Create a certificate from the ca-issuer for the app . NOTE: under usages -server auth This will create the keystore to be used by the java app

```bash
kubectl apply -f cert-manager/server-cert.yaml 
```
Check status of certificate

```bash
kubectl get certificate -n truststores
```

Check the secret created by the certificate resource (Should contain the truststore, keystore, tls.crt, tls.key, ca.crt)

```bash
kubectl describe secret my-app-trustore-secret -n truststores
```

### Deploy Spring Boot Application

We have created a simple spring boot application with a GET API that would return "Hello Stranger" along with a counter. We will go through the steps to secure this app with TLS using the javakeystore generated by cert-manager. The application.properties file in the spring boot project specified the properties to secure the application. 
https://github.com/riazvm/truststore-springboot


Review the cert-manager/spring-boot-app.yaml deployment file to see the corresponsing mappings.

Deploy the application

```bash
kubectl apply -f cert-manager/spring-boot-app.yaml 
```

The deployment creates a service of type load-balancer. Get the load balancer IP 

### Test TLS
To test TLS we will require a client cert and key. For testing purposes we will generate the cert and key from the same issuer. Note   usages: - client auth in the yaml

```bash
kubectl apply -f cert-manager/client-cert.yaml 
```

Test app using curl

```bash
curl https://<load-balancer-ip>/trust
```
This will result in an error. 

Get the client crts and keys

```bash
kubectl get secret my-app-trustore-secret-client -n truststores  -o json | jq -r '.data."tls.crt"'| base64 -d > tls.crt
kubectl get secret my-app-trustore-secret-client -n truststores  -o json | jq -r '.data."tls.key"'| base64 -d > tls.key
kubectl get secret my-app-trustore-secret-client -n truststores  -o json | jq -r '.data."ca.crt"'| base64 -d > ca.crt

```
Test the app

```bash
curl https://<Load balancer IP>/trust --cert tls.crt --key tls.key --cacert ca.crt

```

Usecase 2: Securing Applications using the CSI driver
=======================================================================================

Pre Reqs: Cert-manager should be installed
Note: JKS and pkcs12 are currently not supported by the CSI driver and will be available in a near future release

### Issuer and Certs

Create a namespace for tenancy

```bash
kubectl create ns truststores

```

Create a self signed issuer, create ca cert from the issuer and create a issuer from the CA cert 

```bash
kubectl apply -f cert-manager/issuer.yaml 
```

### Priviledged permissions for OCP

> oc adm policy add-scc-to-user privileged system:serviceaccount:cert-manager:cert-manager-csi-driver

Service account for redis server deployment 

> oc adm policy add-scc-to-user privileged system:serviceaccount:truststores:redis-server-sa

Service account for redis client deployment

> oc adm policy add-scc-to-user privileged system:serviceaccount:truststores:redis-client-sa

### Deploy csi driver

```bash
helm repo add jetstack https://charts.jetstack.io
helm repo update
helm upgrade \
  --install cert-manager-csi-driver jetstack/cert-manager-csi-driver \
  --namespace cert-manager \
  --version v0.3.0
```

## Deploy Application and mount certs using the csi driver

Deploy the redis server and client

```bash
kubectl apply -f csi-driver/redis-server.yaml
kubectl apply -f csi-driver/redis-client.yaml
```

Note: The csi section under volumes is where the csi configuration resides

Test if client works with cert 
```bash
kubectl exec -it -n truststores "$(kubectl get pod -n truststores -l app=redis-client-app -o jsonpath='{.items[0].metadata.name}')" -- redis-cli -h redis-master01 -p 6379 --tls --cacert /redis-client-ssl/certs/ca.crt --cert /redis-client-ssl/certs/tls.crt --key /redis-client-ssl/certs/tls.key ping
```

You should see "PONG" as response.. 

Inspect the cert 

```bash
kubectl exec -it -n truststores "$(kubectl get pod -n truststores -l app=redis-client-app -o jsonpath='{.items[0].metadata.name}')" -- sh -c 'cat /redis-client-ssl/certs/tls.crt'   | openssl x509 -text -noout | HEAD
```
